DependentSorts :
  tm, ty

SimpleSorts :
  tn

FunctionalSymbols :
  pi : (ty , 0) * (ty , 1) -> ty -- sigma : (ty , 0) * (ty , 1) -> ty
  lam : (ty , 0) * (tm , 1) -> tm
  app : (tm , 0) * (tm , 0) -> tm

Axioms :
-- (tm , 0) -- означает \x -> x; (tm , 1) \x -> y, var always term
-- x.B -- func from tm to ty
-- (ty , 2) : tm -> tm -> ty
-- context - only vars
  -- !! how to do basic types? - we have tm, but how to have a substructure on that? like, say, bool?

  KPi =
    forall T1 : ty , x.T2 : ty
      x : T1 |- T2 def |--- |- pi(T1, x.T2) def

  TAbs =  -- !! what happens if I have a "-" in my axioms?
   ------  b : (tm , 1) -- мало, надо знать имена переменных в контексте!
    forall S : ty , x.T : ty , x.t : tm  -- х есть переменная (у метаперем есть сорт)
      x : S |- t : T |--- |- lam(S , x.t) : pi(S , x.T)
                -- Gamma is everywhere, so we check if we have x in context not context equality

  TApp =
    forall t1 : tm , t2 : tm , S : ty, x.T : ty  -- не ругаться если больше параметров чем использованных
      |- t1 : pi(S, x.T) , |- t2 : S |---- |- app(t1 , t2) : T[x:=t2] -- !! tut x.T or T??

Reductions :
  Beta =
    forall x.b : tm , A : ty, a : tm
      |--- |- app(lam(A , x.b) , a) => b [x := a]

  -- no subst on the left here
  -- unit type is hard - why?

  -- no equality in the result, but can be in the premise!


-- can context become larger? (yes), and context of the variable?
-- equality, subst and isTypeOf (lam(A , x.b) : arr(A , B))
-- right of forall can it have terms or not? (x.b : arr(A , B) -- no because ':' is meta op


-- end goal -- ast + parser + typechecker of lang
-- then add implicit params
